function ConvertTo-CompositeResource {
    [CmdletBinding(DefaultParameterSetName = 'ByConfiguration')]
    param
    (
        [Parameter(Mandatory = $true, ParameterSetName = 'ByConfigurationName')]
        [string]
        $ConfigurationName,

        [Parameter(Mandatory = $true, ParameterSetName = 'ByScript')]
        [string]
        $Script,

        [Parameter()]
        [string]
        $ResourceName = $ConfigurationName,

        [Parameter()]
        [string]
        $ModuleName = "$($ConfigurationName)DSC",

        [Parameter(Mandatory = $true)]
        [version]
        $ModuleVersion,

        [Parameter()]
        [string]
        $Author = $env:USERNAME,

        [Parameter()]
        [string]
        $Description = 'Automatically generated by the Composite Resource module.  http://github.com/microsoft/compositeresource',

        [Parameter()]
        [string]
        $OutputPath = '.\'
    )

    switch ($PsCmdlet.ParameterSetName) {
        "ByConfigurationName" {
            $configuration = Get-Command -Name $ConfigurationName -CommandType 'Configuration' -ErrorAction SilentlyContinue
            if (-not $configuration) {
                throw ('Could not find a configuration ''{0}'' loaded in the session.' -f $ConfigurationName)
            }
        }

        "ByScript" {
            # Get the configuration definition ast.
            $parseErrors = $null
            $definitionAst = [System.Management.Automation.Language.Parser]::ParseInput($Script, [ref] $null, [ref] $parseErrors)

            if ($parseErrors) {
                throw $parseErrors
            }

            $astFilter = {
                $args[0] -is [System.Management.Automation.Language.ConfigurationDefinitionAst]
            }

            $configurationDefinitionAst = $definitionAst.Find($astFilter, $false)

            # Get the script block definition ast, from the result of the configuration definition ast.
            $parseErrors = $null
            $definitionAst = [System.Management.Automation.Language.Parser]::ParseInput($configurationDefinitionAst.Body.Extent.Text, [ref] $null, [ref] $parseErrors)

            if ($parseErrors) {
                throw $parseErrors
            }

            $astFilter = {
                $args[0] -is [System.Management.Automation.Language.ScriptBlockAst]
            }

            $configurationContentDefinitionAst = $definitionAst.Find($astFilter, $false)

            # Removes the beginning open brace an ending closing brace of the script block.
            $configurationDefinition = $configurationContentDefinitionAst.Extent.Text
            $configurationDefinition = `
                $configurationDefinition.Remove($configurationContentDefinitionAst.Extent.EndScriptPosition.Offset - 1, 1)
            $configurationDefinition = `
                $configurationDefinition.Remove($configurationContentDefinitionAst.Extent.StartScriptPosition.Offset, 1)

            # Build the correct configuration values.
            $configuration = @{
                Definition = $configurationDefinition
            }

            $ConfigurationName = $configurationDefinitionAst.InstanceName.Value

            # Set default values if they are not set.
            if (-not $PSBoundParameters.ContainsKey('ResourceName')) {
                $ResourceName = $ConfigurationName
            }

            if (-not $PSBoundParameters.ContainsKey('ModuleName')) {
                $ModuleName = "$($ConfigurationName)DSC"
            }
        }
    }

    $moduleFolder = Join-Path -Path $OutputPath -ChildPath $ModuleName
    $versionFolder = Join-Path -Path $moduleFolder -ChildPath $ModuleVersion.ToString()
    $dscResourcesFolder = Join-Path -Path $versionFolder -ChildPath 'DSCResources'
    $configurationFolder = Join-Path -Path $dscResourcesFolder -ChildPath $ResourceName

    # Creates the folder structure if any folder does not exist.
    if (-not (Resolve-Path -Path $configurationFolder -ErrorAction 'SilentlyContinue')) {
        New-Item -Path $configurationFolder -ItemType Directory -Force -ErrorAction Stop | Out-Null
    }

    $resourcePsm1 = Join-Path -Path $configurationFolder -ChildPath "$ResourceName.schema.psm1"
    $resourcePsd1 = Join-Path -Path $configurationFolder -ChildPath "$ResourceName.psd1"
    $modulePsd1 = Join-Path -Path $versionFolder -ChildPath "$ModuleName.psd1"

    Set-Content -Path $resourcePsm1 -Value @"
Configuration $ResourceName
{
$($configuration.Definition)
}
"@

    $resourceNames = @()

    # If we already got a module manifest, then pick up any existing resource names.
    if (Test-Path -Path $modulePsd1) {
        $moduleManifest = Import-PowerShellDataFile -Path $modulePsd1
        $resourceNames = @($moduleManifest.DscResourcesToExport)
    }

    if ($resourceNames -notcontains $ResourceName) {
        $resourceNames += $ResourceName
    }

    New-ModuleManifest -Path $modulePsd1 `
        -Guid (New-Guid).Guid `
        -Author $Author `
        -Description $Description `
        -ModuleVersion $ModuleVersion `
        -DscResourcesToExport $resourceNames

    New-ModuleManifest -Path $resourcePsd1 `
        -RootModule "$ResourceName.schema.psm1" `
        -Guid (New-Guid).Guid
}


$request = Get-Content $req -Raw | ConvertFrom-Json

if ($req_query_config) {
    $config = $req_query_config
}
else {
    $config = $request.config
}

$guid = new-guid | % Guid
$config | set-content "$env:temp\$guid.ps1"
mkdir "$env:temp\$guid\"
ConvertTo-CompositeResource -script "$env:temp\$guid.ps1" -moduleversion '0.1.0' -out "$env:temp\$guid\"
$out = ls "$env:temp\$guid\"

$response = @{
    Config = $out
} | ConvertTo-Json
 
Out-File -InputObject $response -FilePath $res -Encoding Ascii